Горячие клавиши: 
F2 — поменять имя файла 
Ctrl + shift + n — открыть новое окно (browser-like)
Ctrl + \ — разделить окно 
Ctrl + tab — переключение между окнами
Ctrl + shift + p — открыть панель доступа (vscode)
Ctrl w — закрыть вкладку 
Ctrl arrows left/right — указатель через слово 
Shift + arrows left/right — выделения блока текста 
Ctrl + shift arrows + left/right — выделение с перескакиванием через слово 
F5 — запуск кода

Как идёт запуск кода? 
код -> линковка -> прекомпиляция -> ассемблирование

Прекомпиляция:
Раскрытие всех #include (около 36 тыс. строк кода)
Если писать #include "bits/stdc++.h" вместо #include, всё уже включено, но занимает 130 тыс. строк (сильно дольше)
ООП (Объектно-ориентированное программирование): 
Чем структура отличается от класса? 
В классе данные могут зависеть друг от друга. 
Для класса мы пишем методы (функции) внутри класса. 
В структуре функции пишутся вне структуры.

Конструктор:
Имя класса и переменные, которые нужны обязательно задавать какие-то данные, без них код не работает вызывается при "рождении" переменной
Citizen(std::string name_) : 
    name(name_), health(100), 
    is_alive(true), home(nullptr)
Деструктор:
~Имя класса и всё. он ничего не принимает вызывается при "смерти" переменной (заканчивается область видимости)
~Citizen() {
      if (is_alive) {
          std::cout << name << " died\n";
      }
}
Public: Можно во всем коде менять переменные в паблике.
Private: Методы, которые нельзя менять вне методов класса.

Геттеры: функции, которые выводят данные. С ними нельзя вывести данные просто через переменную, нужно вызвать функцию 
Пример геттера:
int GetHealth() {
        return health;
}
Сеттеры: функция, которая принимает данные.
Пример сеттера:
void SetHealth(int health_) {
        health = health_;
        health = std::min(100, health);
}
*Пишутся Get/Set + имя переменной

Константные функции: пишем перед скобкой, когда в функции никак не меняются данные.
*Название функции () const
{
  ...;
}

Чтобы объекты не копировались и не вызывались по несколько раз, логичнее передавать ссылки(int&) и принимать указатели(int*)!
Разделение объявления переменных: 
Например, когда классы зависят друг от друга, так что нельзя писать их друг перед другом. 
Для этого мы объявляем классы в самом начале с объявлением их методов, но без внутренностей.
После расписываем методы отдельно как отдельные функции, но с "название класса:" в начале
Пример:
City::City(std::string title_) : title(title_) {
}

std::string City::GetTitle() {
    return title;
}

void City::print() {
    for (const Citizen* person : people) {
        person->print(); // <=> (*person).print();
    }
}

void City::AddResident(Citizen *person) {
    people.push_back(person);
    person->SetHome(this); // <-- поговорим потом
}
